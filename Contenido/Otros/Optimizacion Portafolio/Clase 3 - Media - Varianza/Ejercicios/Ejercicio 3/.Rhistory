par(new=T)
plot(cbind(x,y),col="blue",xlab="X",ylab="Y",xlim=range(c(DatosFin[,1],x)),ylim=range(c(DatosFin[,2],y)))
DatosFin=cbind(qnorm(pvars[,1],mean =  0 ,sd = 1),qnorm(pvars[,2],mean =  0 ,sd = 1))
plot(DatosFin,col="blue",xlab="X",ylab="Y",xlim=range(c(DatosFin[,1],x)),ylim=range(c(DatosFin[,2],y)))
par(new=T)
plot(cbind(x,y),xlab="X",ylab="Y",xlim=range(c(DatosFin[,1],x)),ylim=range(c(DatosFin[,2],y)))
plot(cbind(x,y),xlab="X",ylab="Y",xlim=range(c(DatosFin[,1],x)),ylim=range(c(DatosFin[,2],y)))
par(new=T)
plot(DatosFin,col="blue",xlab="X",ylab="Y",xlim=range(c(DatosFin[,1],x)),ylim=range(c(DatosFin[,2],y)))
plot(pvars)
plot(pvars,xlab="X sim uniforme",ylab="Y sim uniforme")
plot(pvars,xlab="X sim uniforme",ylab="Y sim uniforme",col="blue")
rm(list = ls())
options(scipen = 10000000)
##### --------- Path: automatico  --------- #####
path <<- gsub(rstudioapi::getActiveDocumentContext()$path,pattern = "/Ejercicio 3.+",replacement = "")
setwd(paste0(path,'/Ejercicio 3'))
##### -------- librerias ------- ######
librerias <- c("readxl","ggplot2","scales",'timeSeries','timeSeries','forecast','rugarch','fBasics','moments','tseries','fPortfolio','dplyr','zoo','plotly')
###### ----- Instalacion liberarias ------ ####
if(length(setdiff(librerias, rownames(installed.packages()))) > 0){
install.packages(setdiff(librerias, rownames(installed.packages())))}
invisible(sapply(librerias, require, character.only = TRUE,quietly = TRUE))
###### ----------- Cargar datos --------- #######
##### --------- Datos acciones ------ #####
Acciones = as.data.frame(read_excel('Datos.xlsx',sheet = 'Close'))
Acciones= na.locf(Acciones)
## ---- Organizar nombres --- ###
rownames(Acciones) = Acciones[,'Fecha']
Acciones = Acciones[,-1]
## Vamos a generar la serie semanal ##
DatosSem=seq(as.Date(rownames(Acciones))[1],as.Date(rownames(Acciones))[nrow(Acciones)],by = "week")
# En caso de festivos, tomamos el dia mas cercano.
DatosSem=sapply(DatosSem,function(x){which.min(abs(as.Date(rownames(Acciones))-x))})
# Nos quedamos solo con los datos semanales
Acciones=Acciones[DatosSem,]
# Generamos cuatro estrategias (1,2,3,4): minima varianza en 2 y maximo retorno en 2.
# Una con shrink y otra con media y covarianza historica (estimador de max vero).
Retorno1=Retorno2=NULL
Retorno3=Retorno4=NULL
i=52
# Definimos que datos usar con un rolling window.
Datos=Retornos[(i-51):i,]
# Corremos nuestra funcion de shrink con suavizamiento.
Covarianza1=shrinkEstimator(Datos)
# Generamos la serie de retornos
Retornos=na.omit(apply(Acciones,2,returns))
rownames(Retornos)=rownames(Acciones)[-1]
# Definimos que datos usar con un rolling window.
Datos=Retornos[(i-51):i,]
# Corremos nuestra funcion de shrink con suavizamiento.
Covarianza1=shrinkEstimator(Datos)
lambda= 0.086
TiempoFin=nrow(X)
##Pesos
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
##Mu
mu=lambda/(1-(1-lambda)^TiempoFin)*w%*%X
mu=matrix(mu,ncol=1)
##Sigma
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
##
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
X=Datos
lambda= 0.086
TiempoFin=nrow(X)
##Pesos
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
##Mu
mu=lambda/(1-(1-lambda)^TiempoFin)*w%*%X
mu=matrix(mu,ncol=1)
##Sigma
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
##
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
lambda= 0.086
TiempoFin=nrow(X)
##Pesos
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
##Mu
mu=lambda/(1-(1-lambda)^TiempoFin)*w%*%X
mu=matrix(mu,ncol=1)
##Sigma
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
retornos = X
lambda= 0.086
TiempoFin=nrow(X)
##Pesos
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
##Mu
mu=lambda/(1-(1-lambda)^TiempoFin)*w%*%X
mu=matrix(mu,ncol=1)
##Sigma
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
##
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
# Definimos una funcion que aplique el estimador de Shrink con suavizamiento exponencial.
shrinkEstimator = function(X,mu,sigma){
retornos = X
I=diag(ncol(var(X)))
C=mean(eigen(var(X))$values)*I
Traza=0
for (i in 1:nrow(X)){
Traza=Traza+tr(((t(t(X[i,]))%*%t(X[i,]))-sigma)%*%(t(t(X[i,]))%*%t(X[i,]))-sigma)
}
alfa=((Traza/nrow(X)))/(tr(t(sigma-C)%*%(sigma-C))*nrow(X))
if (alfa>0.9){
alfa=0.9
}
if (alfa<0.1){
alfa=0.1
}
alfa=matrix(rep(alfa,ncol(X)*ncol(X)),nrow=ncol(X))
sigmaS=(1-alfa)*sigma+alfa*C
lambda = eigen(sigmaS)$values
N = ncol(retornos)
unos = rep(1,N)
b = (unos%*%solve(sigmaS)%*%t(t(mu)))/(unos%*%solve(sigmaS)%*%t(t(unos)))*unos
lambda = eigen(sigmaS)$values
alpha = 1/nrow(retornos)*(N*mean(lambda)-2*lambda[1])/(sum((mu-b)^2))
###############################################################################################
if(alpha>=0.9){ alpha=0.9 }
if(alpha<=0.1){ alpha=0.1 }
###############################################################################################
muS = (1-alpha)*mu + alpha*b
return( list(Sigma=sigmaS,mu=muS) )
}
shrinkEstimator(Datos,mu,sigma = sigma)
#Estimador de shink con suavizamiento exponencial
shrinkEstimator = function(X){
retornos = X
I=diag(ncol(var(X)))
C=mean(eigen(var(X))$values)*I
Traza=0
for (i in 1:nrow(X)){
Traza=Traza+tr(((t(t(X[i,]))%*%t(X[i,]))-sigma)%*%(t(t(X[i,]))%*%t(X[i,]))-sigma)
}
alfa=((Traza/nrow(X)))/(tr(t(sigma-C)%*%(sigma-C))*nrow(X))
if (alfa>0.9){
alfa=0.9
}
if (alfa<0.1){
alfa=0.1
}
alfa=matrix(rep(alfa,ncol(X)*ncol(X)),nrow=ncol(X))
sigmaS=(1-alfa)*sigma+alfa*C
lambda = eigen(sigmaS)$values
N = ncol(retornos)
unos = rep(1,N)
b = (unos%*%solve(sigmaS)%*%t(t(mu)))/(unos%*%solve(sigmaS)%*%t(t(unos)))*unos
lambda = eigen(sigmaS)$values
alpha = 1/nrow(retornos)*(N*mean(lambda)-2*lambda[1])/(sum((mu-b)^2))
###############################################################################################
if(alpha>=0.9){ alpha=0.9 }
if(alpha<=0.1){ alpha=0.1 }
###############################################################################################
muS = (1-alpha)*mu + alpha*b
return( list(Sigma=sigmaS,mu=muS) )
}
X
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- count(VARselect(X, type = "const")$selection)
##### -------- librerias ------- ######
librerias <- c("readxl","ggplot2","scales",'timeSeries','timeSeries','forecast','rugarch','fBasics','moments','tseries','PortfolioAnalytics','dplyr','zoo','nleqslv','usdm','lubridate','xts','forecast','RQuantLib','tseries','urca','nleqslv','uroot','vars','GeneralizedHyperbolic','plyr','fUnitRoots','xtable','mvtnorm','reshape2','ggplot2','grid','fitdistrplus','tsDyn')
###### ----- Instalacion liberarias ------ ####
if(length(setdiff(librerias, rownames(installed.packages()))) > 0){
install.packages(setdiff(librerias, rownames(installed.packages())))}
invisible(sapply(librerias, require, character.only = TRUE,quietly = TRUE))
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- count(VARselect(X, type = "const")$selection)
p     <- max(c(2, p$x[which.max(p$freq)[1]])); p
vecm  <- ca.jo(dv, type = "eigen", ecdet = "const", K = p)
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 1)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]])
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = data[179:180,-c(1:2)]))
nsim=1000
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = data[179:180,-c(1:2)]))
HorizonteRiesgo=1
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = data[179:180,-c(1:2)]))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,1)
))
MatCoefB
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,2)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,3)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,6)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,7)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = tail(X)))
p
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = tail(X,3)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = tail(X,6)))
MatCoefB
tail(X)
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,7)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,3)))
nsim
tail(X,3)
model
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- count(VARselect(X, type = "const")$selection)
p     <- max(c(2, p$x[which.max(p$freq)[1]])); p
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
vecm
p
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 1)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]])
MatCoefB
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,3)))
tail(X,3)
p
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- count(VARselect(X, type = "const")$selection)
p     <- 2
p
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 1)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]])
nsim=1000
HorizonteRiesgo=1
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,3)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,2)))
model <- vec2var(vecm, r = 2)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]])
nsim=1000
HorizonteRiesgo=1
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,2)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,1)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,2)))
MatCoefB
nsim=1000
HorizonteRiesgo=1
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,2)))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = tail(X,1)))
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- 2
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 2)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]])
nsim=1000
HorizonteRiesgo=1
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- count(VARselect(X, type = "const")$selection)
p     <- max(c(2, p$x[which.max(p$freq)[1]])); p
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 1)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]])
MatCoefB
nsim=1000
HorizonteRiesgo=1
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,2))))
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
as.data.frame(tail(X,2))
MatCoefB
class( as.data.frame(tail(X,2)))
p
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- count(VARselect(X, type = "const")$selection)
p     <- max(c(2, p$x[which.max(p$freq)[1]])); p
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 1)
model$A[[1]]
model$A[[2]]
model$deterministic
model
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]],model$A[[3]])
MatCoefB
nsim=1000
HorizonteRiesgo=1
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
MatCoefB
HorizonteRiesgo
HorizonteRiesgo=12
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
HorizonteRiesgo=2
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
SimsVAR
dim(SimsVAR)
(SimsVAR[,1,])
t(SimsVAR[,1,])
VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3)))
as.data.frame(tail(X,3))
HorizonteRiesgo=2
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
HorizonteRiesgo=4
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
dim(SimsVAR)
HorizonteRiesgo=2
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
SimsVAR[1,,]
MatCoefB
as.data.frame(tail(X,3))
model <- vec2var(vecm, r = 0)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]],model$A[[3]])
nsim=1000
HorizonteRiesgo=2
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
model <- vec2var(vecm, r = 1)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]],model$A[[3]])
nsim=1000
HorizonteRiesgo=2
SimsVAR<-replicate(n=nsim,VAR.sim(B=MatCoefB,n=HorizonteRiesgo,include="const", lag=p, starting = as.data.frame(tail(X,3))))
SimsVAR[1,,]
summary(t(SimsVAR[1,,]))
model$resid
colSds(model$resid)
starting = as.data.frame(tail(X,3))
starting
lag=p
n=HorizonteRiesgo
B=MatCoefB
MatCoefB
MatCoefB[,-1]
lag
starting
c(starting)
unlist(c(t(starting)))
MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))
MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))+MatCoefB[,1]
resid
residual=model$resid
residual
apply(residual,2,sample,size=1)
MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))+MatCoefB[,1]+t(apply(residual,2,sample,size=1))
t(apply(residual,2,sample,size=1))
MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))+MatCoefB[,1]+t(t(apply(residual,2,sample,size=1)))
SimVAR=function(B,n=1, lag, starting = NULL,residual){
return(MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))+MatCoefB[,1]+t(t(apply(residual,2,sample,size=1))))
}
SimsVAR<-replicate(n=nsim,SimVAR(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = as.data.frame(tail(X,3))),residual=model$resid)
SimVAR=function(B,n=1, lag, starting = NULL,residual){
return(MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))+MatCoefB[,1]+t(t(apply(residual,2,sample,size=1))))
}
SimsVAR<-replicate(n=nsim,SimVAR(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = as.data.frame(tail(X,3))),residual=model$resid)
SimsVAR<-replicate(n=nsim,SimVAR(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = as.data.frame(tail(X,3)),residual=model$resid))
dim(SimsVAR)
summary(t(SimsVAR[,1,]))
# 4. VAR
VAR=function(X){
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- 3
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 1)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]],model$A[[3]])
nsim=1000
HorizonteRiesgo=1
SimVAR=function(B,n=1, lag, starting = NULL,residual){
return(MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))+MatCoefB[,1]+t(t(apply(residual,2,sample,size=1))))
}
SimsVAR<-replicate(n=nsim,SimVAR(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = as.data.frame(tail(X,3)),residual=model$resid))
mu=colMeans(SimsVAR[,1,])
sigma=cov(SimsVAR[,1,])
return(mu=mu,sigma=sigma)
}
VAR(X)
# 4. VAR
VAR=function(X){
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- 3
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 1)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]],model$A[[3]])
nsim=1000
HorizonteRiesgo=1
SimVAR=function(B,n=1, lag, starting = NULL,residual){
return(MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))+MatCoefB[,1]+t(t(apply(residual,2,sample,size=1))))
}
SimsVAR<-replicate(n=nsim,SimVAR(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = as.data.frame(tail(X,3)),residual=model$resid))
mu=colMeans(SimsVAR[,1,])
sigma=cov(SimsVAR[,1,])
return(list(mu=mu,sigma=sigma))
}
VAR(X)
SimsVAR<-replicate(n=nsim,SimVAR(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = as.data.frame(tail(X,3)),residual=model$resid))
mu=colMeans(SimsVAR[,1,])
sigma=cov(SimsVAR[,1,])
# 4. VAR
VAR=function(X){
#Se calibra un modelo VAR multivariado para simular el IPC, el dólar y el Brent de manera integrada
#para incorporar correlaciones ya que no son independientes entre sí. EL modelo calibrado es un VAR con
#constante.
## Definir modelo
p     <- 3
vecm  <- ca.jo(X, type = "eigen", ecdet = "const", K = p)
data.frame(test = round(summary(vecm)@teststat, 2), summary(vecm)@cval)
model <- vec2var(vecm, r = 1)
## Se generan simulaciones del VAR usando la función VAR.sim junto con replicate para crear 1000
#simulaciones de cada factor de riesgo.
MatCoefB=cbind(model$deterministic,model$A[[1]], model$A[[2]],model$A[[3]])
nsim=1000
HorizonteRiesgo=1
SimVAR=function(B,n=1, lag, starting = NULL,residual){
return(MatCoefB[,-1]%*%t(t(unlist(c(t(starting)))))+MatCoefB[,1]+t(t(apply(residual,2,sample,size=1))))
}
SimsVAR<-replicate(n=nsim,SimVAR(B=MatCoefB,n=HorizonteRiesgo, lag=p, starting = as.data.frame(tail(X,3)),residual=model$resid))
mu=colMeans(t(SimsVAR[,1,]))
sigma=cov(t(SimsVAR[,1,]))
return(list(mu=mu,sigma=sigma))
}
VAR(X)
UtilidadPyG = function(DistribucionPyG,param){
if(param==1){
utilidad <- function(retorno) {
return(log(retorno))
}
}else{
utilidad <- function(retorno) {
return(((retorno)^(1-param)-1)/(1-param))
}
}
return(mean(sapply(DistribucionPyG,utilidad)))
}
CalcularAversion = function(Equiv0){
#     #Funcion que calibra la funcion de utilidad anterior a loterias equivalentes segun el nivel de PyG.
fun_resolver <- function(param,E1){
#### ----- Loteria 50%*U() + 50% U()
return(0.5*UtilidadPyG(0.9,param)+0.5*UtilidadPyG(1.1,param)-UtilidadPyG(1+E1,param))
}
return(nleqslv(ifelse(Equiv0>0,2,0), fun_resolver, E1=Equiv0, control=list(ftol=1e-14))$x)
}
ParamAversion<<-CalcularAversion(Equiv0=-0.035)
ParamAversion
