w=matrix(seq(0,1,0.001),ncol=1)
w=cbind(w,1-w)
Sigma1=apply(w,1,function(x){t(x)%*%Cov1%*%(x)})
Sigma2=apply(w,1,function(x){t(x)%*%Cov2%*%(x)})
Portafolio1=w[which.min(abs(sqrt(Sigma1))),]
Portafolio2=w[which.min(abs(sqrt(Sigma2))),]
Retorno1=c(Retorno1,sum(Portafolio1*Retornos[i+1,]))
Retorno2=c(Retorno2,sum(Portafolio2*Retornos[i+1,]))
}
plot(Retorno1)
plot(cumprod(Retorno1+1),type="l")
Acum1=cumprod(Retorno1+1)
Acum2=cumprod(Retorno2+1)
plot(Acum1,type="l",range=range(c(Acum1,Acum2)))
plot(Acum1,type="l",ylim=range(c(Acum1,Acum2)))
warnings()
range(c(Acum1,Acum2))
plot(Acum1,type="l",ylim=range(c(Acum1,Acum2)))
par(new=T)
plot(Acum2,col=2,type="l",ylim=range(c(Acum1,Acum2)))
Acum1
Acum2
sd(Acum1)
sd(Retorno2)
Retorno1
sd(Retorno1)
sd(v)
sd()
sd(Retorno2)
Mu1=apply(w,1,function(x){t(x)%*%Mu1})
Mu1
Mu2=apply(w,1,function(x){t(x)%*%Mu2})
Portafolio3=w[which.max(Mu1),]
Portafolio4=w[which.max(Mu2),]
Portafolio3
Portafolio4
Retorno1=Retorno2=NULL
Retorno3=Retorno4=NULL
for(i in 52:(nrow(Retornos)-1)){
Datos=Retornos[(i-51):i,]
Covarianza1=shrinkEstimatorQuantil(Datos)
Mu1=Covarianza1$mu
Cov1=Covarianza1$Sigma
Mu2=colMeans(Datos)
Cov2=cov(Datos)
TargetSigma1=mean(sqrt(diag(Cov1)))/2
TargetSigma2=mean(sqrt(diag(Cov2)))/2
w=matrix(seq(0,1,0.001),ncol=1)
w=cbind(w,1-w)
Sigma1=apply(w,1,function(x){t(x)%*%Cov1%*%(x)})
Sigma2=apply(w,1,function(x){t(x)%*%Cov2%*%(x)})
Mu1=apply(w,1,function(x){t(x)%*%Mu1})
Mu2=apply(w,1,function(x){t(x)%*%Mu2})
Portafolio1=w[which.min(abs(sqrt(Sigma1))),]
Portafolio2=w[which.min(abs(sqrt(Sigma2))),]
Portafolio3=w[which.max(Mu1),]
Portafolio4=w[which.max(Mu2),]
Retorno1=c(Retorno1,sum(Portafolio1*Retornos[i+1,]))
Retorno2=c(Retorno2,sum(Portafolio2*Retornos[i+1,]))
Retorno3=c(Retorno3,sum(Portafolio3*Retornos[i+1,]))
Retorno4=c(Retorno4,sum(Portafolio4*Retornos[i+1,]))
}
Acum1=cumprod(Retorno3+1)
Acum2=cumprod(Retorno4+1)
plot(Acum1,type="l",ylim=range(c(Acum1,Acum2)))
par(new=T)
plot(Acum2,col=2,type="l",ylim=range(c(Acum1,Acum2)))
sapply(30:length(Retorno1),function(x){sd(Retorno1[(x-29):x])})
Varianza1=sapply(30:length(Retorno1),function(x){sd(Retorno1[(x-29):x])})
Varianza2=sapply(30:length(Retorno2),function(x){sd(Retorno2[(x-29):x])})
plot(Varianza1,type="l",ylim=range(c(Varianza1,Varianza2)))
par(new=T)
plot(Varianza2,col=2,type="l",ylim=range(c(Varianza1,Varianza2)))
###### --------------------- Ejercicio 1 ----------------- ############
####### ----------- Limpiar ambiente ------- ######
rm(list = ls())
options(scipen = 10000000)
##### --------- Path: automatico  --------- #####
path <<- gsub(rstudioapi::getActiveDocumentContext()$path,pattern = "/Ejercicio 3.+",replacement = "")
setwd(paste0(path,'/Ejercicio 3'))
##### -------- librerias ------- ######
librerias <- c("readxl","ggplot2","scales",'timeSeries','timeSeries','forecast','rugarch','fBasics','moments','tseries','fPortfolio','dplyr','zoo','plotly')
###### ----- Instalacion liberarias ------ ####
if(length(setdiff(librerias, rownames(installed.packages()))) > 0){
install.packages(setdiff(librerias, rownames(installed.packages())))}
invisible(sapply(librerias, require, character.only = TRUE,quietly = TRUE))
###### ----------- Cargar datos --------- #######
##### --------- Datos acciones ------ #####
Acciones = as.data.frame(read_excel('Datos.xlsx',sheet = 'Close'))
Acciones= na.locf(Acciones)
## ---- Organizar nombres --- ###
rownames(Acciones) = Acciones[,'Fecha']
Acciones = Acciones[,-1]
## Generamos un dato semanal ##
DatosSem=seq(as.Date(rownames(Acciones))[1],as.Date(rownames(Acciones))[nrow(Acciones)],by = "week")
DatosSem=sapply(DatosSem,function(x){which.min(abs(as.Date(rownames(Acciones))-x))})
Acciones=Acciones[DatosSem,]
shrinkEstimator = function(X){
# Esta funcion calcula los retornos esperados usando el shrink Estimator (libro Meucci "Risk and Asset Allocation" secs 4.4.1 y 6.7.2) .
# Para la covarianza se usa el shrinkEstimator de Rmetrics.
# Inputs:
# X: timeSeries con los retornos (sin NA's) de los activos para estimar la media y la varianza covarianza
# Outputs:
# 1. out$Sigma: Matriz de Varianza Covarianza
# 2. out$mu: Vector con los retornos Esperados para t+1
retornos = X#[which(as.Date(rownames(X))<=as.Date("2012-2-8")),]
lambda= 0.086#0.043 #0.003 #0.086 #0.043
TiempoFin=nrow(X)
##Pesos
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
##Mu
mu=lambda/(1-(1-lambda)^TiempoFin)*w%*%X
mu=matrix(mu,ncol=1)
##Sigma
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
##
Sigma=matrix(0,ncol=ncol(X), nrow=ncol(X))
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
I=diag(ncol(var(X)))
C=mean(eigen(var(X))$values)*I
Traza=0
for (i in 1:nrow(X)){
Traza=Traza+tr(((t(t(X[i,]))%*%t(X[i,]))-sigma)%*%(t(t(X[i,]))%*%t(X[i,]))-sigma)
}
alfa=((Traza/nrow(X)))/(tr(t(sigma-C)%*%(sigma-C))*nrow(X))
if (alfa>0.9){
alfa=0.9
}
if (alfa<0.1){
alfa=0.1
}
alfa=matrix(rep(alfa,ncol(X)*ncol(X)),nrow=ncol(X))
sigmaS=(1-alfa)*sigma+alfa*C
lambda = eigen(sigmaS)$values
N = ncol(retornos)
unos = rep(1,N)
#b = unos%*%mu/N*unos
b = (unos%*%solve(sigmaS)%*%t(t(mu)))/(unos%*%solve(sigmaS)%*%t(t(unos)))*unos
lambda = eigen(sigmaS)$values
alpha = 1/nrow(retornos)*(N*mean(lambda)-2*lambda[1])/(sum((mu-b)^2))
###############################################################################################
#########  OJO!!! TEMPORAL!!! MIENTRAS SE ENTIENDE PRUEBA TECNICA DE ALPHA OPTIMO  ############
if(alpha>=0.9){ alpha=0.9 }
if(alpha<=0.1){ alpha=0.1 }
#  alpha=0.8
###############################################################################################
#alpha = 1/nrow(retornos)*(sum(diag(sigma))-2*lambda[1])/(sum((mu-b)^2))
muS = (1-alpha)*mu + alpha*b
#(1+muS)^(252/4)-1
print(c("alpha",alpha))
return( list(Sigma=sigmaS,mu=muS) )
}
Retornos=na.omit(apply(Acciones,2,returns))
rownames(Retornos)=rownames(Acciones)[-1]
Retorno1=Retorno2=NULL
Retorno3=Retorno4=NULL
for(i in 52:(nrow(Retornos)-1)){
Datos=Retornos[(i-51):i,]
Covarianza1=shrinkEstimator(Datos)
Mu1=Covarianza1$mu
Cov1=Covarianza1$Sigma
Mu2=colMeans(Datos)
Cov2=cov(Datos)
TargetSigma1=mean(sqrt(diag(Cov1)))/2
TargetSigma2=mean(sqrt(diag(Cov2)))/2
w=matrix(seq(0,1,0.001),ncol=1)
w=cbind(w,1-w)
Sigma1=apply(w,1,function(x){t(x)%*%Cov1%*%(x)})
Sigma2=apply(w,1,function(x){t(x)%*%Cov2%*%(x)})
Mu1=apply(w,1,function(x){t(x)%*%Mu1})
Mu2=apply(w,1,function(x){t(x)%*%Mu2})
Portafolio1=w[which.min(abs(sqrt(Sigma1))),]
Portafolio2=w[which.min(abs(sqrt(Sigma2))),]
Portafolio3=w[which.max(Mu1),]
Portafolio4=w[which.max(Mu2),]
Retorno1=c(Retorno1,sum(Portafolio1*Retornos[i+1,]))
Retorno2=c(Retorno2,sum(Portafolio2*Retornos[i+1,]))
Retorno3=c(Retorno3,sum(Portafolio3*Retornos[i+1,]))
Retorno4=c(Retorno4,sum(Portafolio4*Retornos[i+1,]))
}
Acum1=cumprod(Retorno3+1)
Acum2=cumprod(Retorno4+1)
plot(Acum1,type="l",ylim=range(c(Acum1,Acum2)))
par(new=T)
plot(Acum2,col=2,type="l",ylim=range(c(Acum1,Acum2)))
Varianza1=sapply(30:length(Retorno1),function(x){sd(Retorno1[(x-29):x])})
Varianza2=sapply(30:length(Retorno2),function(x){sd(Retorno2[(x-29):x])})
plot(Varianza1,type="l",ylim=range(c(Varianza1,Varianza2)))
par(new=T)
plot(Varianza2,col=2,type="l",ylim=range(c(Varianza1,Varianza2)))
source('C:/Users/USUARIO/Dropbox (Quantil)/Uniandes Portafolio/Clases/Clase 3 - Optimizacion/Ejercicios/Ejercicio 3/Ejercicio 3.R')
portfolioOptimQP(sigma = Covarianza,mu=)
###### --------------------- Ejercicio 2: Funcion de utilidad ----------------- ############
####### ----------- Limpiar ambiente ------- ######
rm(list = ls())
options(scipen = 10000000)
##### --------- Path: automatico  --------- #####
path <<- gsub(rstudioapi::getActiveDocumentContext()$path,pattern = "/Ejercicio 2.+",replacement = "")
setwd(paste0(path,'/Ejercicio 2'))
##### -------- librerias ------- ######
librerias <- c("readxl","ggplot2","scales",'timeSeries','timeSeries','forecast','rugarch','fBasics','moments','tseries','PortfolioAnalytics','dplyr','zoo','nleqslv')
###### ----- Instalacion liberarias ------ ####
if(length(setdiff(librerias, rownames(installed.packages()))) > 0){
install.packages(setdiff(librerias, rownames(installed.packages())))}
invisible(sapply(librerias, require, character.only = TRUE,quietly = TRUE))
##### --------- Datos acciones ------ #####
Acciones = as.data.frame(read_excel('Colcap.xlsx',sheet = 'Close'))
Acciones= na.locf(Acciones)
## ---- Organizar nombres --- ###
Fechas_originales = Acciones[,'Fecha']
Acciones = Acciones[,-1]
#### ------ Retornos simples ------ ####
Acciones = apply(Acciones, 2, function(x){returns(x,method='simple')})[-1,]
Acciones = as.data.frame(Acciones)
rownames(Acciones) = Fechas_originales[-1]
Acciones = Acciones[,c("GRUPOSURA","NUTRESA")]
rm(list = ls())
options(scipen = 10000000)
##### --------- Path: automatico  --------- #####
path <<- gsub(rstudioapi::getActiveDocumentContext()$path,pattern = "/Ejercicio 2.+",replacement = "")
setwd(paste0(path,'/Ejercicio 2'))
##### -------- librerias ------- ######
librerias <- c("readxl","ggplot2","scales",'timeSeries','timeSeries','forecast','rugarch','fBasics','moments','tseries','PortfolioAnalytics','dplyr','zoo','nleqslv')
###### ----- Instalacion liberarias ------ ####
if(length(setdiff(librerias, rownames(installed.packages()))) > 0){
install.packages(setdiff(librerias, rownames(installed.packages())))}
invisible(sapply(librerias, require, character.only = TRUE,quietly = TRUE))
##### --------- Datos acciones ------ #####
Acciones = as.data.frame(read_excel('Colcap.xlsx',sheet = 'Close'))
Acciones= na.locf(Acciones)
## ---- Organizar nombres --- ###
Fechas_originales = Acciones[,'Fecha']
Acciones = Acciones[,-1]
#### ------ Retornos simples ------ ####
Acciones = apply(Acciones, 2, function(x){returns(x,method='simple')})[-1,]
Acciones = as.data.frame(Acciones)
rownames(Acciones) = Fechas_originales[-1]
Acciones = Acciones[,c("GRUPOSURA","NUTRESA")]
###### ---------- Calcular frontera: Forma 2 -------- ##########
###### ------- Especificacion del portafolio ------ ######
espcartera<-portfolioSpec()
###### ------- Puntos de la frontera ------ ######
setNFrontierPoints(espcartera) <- 1000
###### ------- Restricciones: Positivas ------ ######
constraints="LongOnly"
###### ------- Construccion de la frontera ------ ######
Frontera <- portfolioFrontier(as.timeSeries(Acciones),spec=espcartera,constraints )
er_p_auto = Frontera@portfolio@portfolio$targetReturn[,'mean']
sd_p_auto = Frontera@portfolio@portfolio$targetRisk[,"Sigma"]
UtilidadPyG = function(DistribucionPyG,param){
#Funcion que mide la bondad de una distribucion de PyG. Funcion de utilidad u(x) = (x+b)^a,
#donde x es el PyG en DECIMALES, a<1. Esta funci?n se representa con una aversi?n al riesgo decreciente
#(igual a (1-a)/(x+L)), consistente con lo que se puede esperar en el manejo del libro. b puede ser visto
#como un nivel de tolerancia a p?rdidas m?ximas. Se devuelve una constante m?nima para valores por debajo.
if(param==1){
utilidad <- function(retorno) {
return(log(retorno))
}
}else{
utilidad <- function(retorno) {
return(((retorno)^(1-param)-1)/(1-param))
}
}
return(mean(sapply(DistribucionPyG,utilidad)))
}
######## -------- Estimacion del Parametro de Aversion ---------- #####
CalcularAversion = function(Equiv0){
Equiv0 = Equiv0/100
#     #Funcion que calibra la funcion de utilidad anterior a loterias equivalentes segun el nivel de PyG.
fun_resolver <- function(param,E1){
#### ----- Loteria 50%*U() + 50% U()
return(0.5*UtilidadPyG(1,param)+0.5*UtilidadPyG(2,param)-UtilidadPyG(1+E1,param))
}
return(nleqslv(ifelse(Equiv0>0,2,0), fun_resolver, E1=Equiv0, control=list(ftol=1e-14))$x)
}
## --- Paso 1: Ajustar el valor en millones --- ###
ParamAversion<<-CalcularAversion(Equiv0=20)
Simulacion=sapply(1:length(er_p_auto),function(x){rnorm(1000,er_p_auto[x],sd_p_auto[x])})
PortOptim=which.max(apply(1+Simulacion,2,UtilidadPyG,param=ParamAversion))
plot(er_p_auto,x=sd_p_auto)
points(x=sd_p_auto[PortOptim],y=er_p_auto[PortOptim],col=2)
points(x=sd_p_auto[PortOptim],y=er_p_auto[PortOptim],col=2)
Simulacion=sapply(1:length(er_p_auto),function(x){rnorm(1000,(1+er_p_auto[x])^250-1,sqrt(250)*sd_p_auto[x])})
PortOptim=which.max(apply(1+Simulacion,2,UtilidadPyG,param=ParamAversion))
plot(er_p_auto,x=sd_p_auto)
plot((1+er_p_auto)^250-1,x=sqrt(250)*sd_p_auto)
points(x=sd_p_auto[PortOptim],y=er_p_auto[PortOptim],col=2)
PortOptim
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2)
Simulacion=sapply(1:length(er_p_auto),function(x){rnorm(1000,(1+er_p_auto[x])^250-1,sqrt(250)*sd_p_auto[x])})
PortOptim=which.max(apply(1+Simulacion,2,UtilidadPyG,param=ParamAversion))
plot((1+er_p_auto)^250-1,x=sqrt(250)*sd_p_auto)
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2)
Simulacion=sapply(1:length(er_p_auto),function(x){rnorm(10000,(1+er_p_auto[x])^250-1,sqrt(250)*sd_p_auto[x])})
PortOptim=which.max(apply(1+Simulacion,2,UtilidadPyG,param=ParamAversion))
plot((1+er_p_auto)^250-1,x=sqrt(250)*sd_p_auto)
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2)
Simulacion=sapply(1:length(er_p_auto),function(x){rnorm(10000,(1+er_p_auto[x])^250-1,sqrt(250)*sd_p_auto[x])})
PortOptim=which.max(apply(1+Simulacion,2,UtilidadPyG,param=ParamAversion))
plot((1+er_p_auto)^250-1,x=sqrt(250)*sd_p_auto)
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2)
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2,pch=2)
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2,pch=15)
plot((1+er_p_auto)^250-1,x=sqrt(250)*sd_p_auto)
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2,pch=15)
plot((1+er_p_auto)^250-1,x=sqrt(250)*sd_p_auto,type="l")
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2,pch=15)
plot((1+er_p_auto)^250-1,x=sqrt(250)*sd_p_auto,type="l",xlab="Volatilidad",ylab="Retorno")
points(x=sqrt(250)*sd_p_auto[PortOptim],y=(1+er_p_auto[PortOptim])^250-1,col=2,pch=15)
rm(list = ls())
options(scipen = 10000000)
##### --------- Path: automatico  --------- #####
path <<- gsub(rstudioapi::getActiveDocumentContext()$path,pattern = "/Ejercicio 3.+",replacement = "")
setwd(paste0(path,'/Ejercicio 3'))
##### -------- librerias ------- ######
librerias <- c("readxl","ggplot2","scales",'timeSeries','timeSeries','forecast','rugarch','fBasics','moments','tseries','fPortfolio','dplyr','zoo','plotly')
###### ----- Instalacion liberarias ------ ####
if(length(setdiff(librerias, rownames(installed.packages()))) > 0){
install.packages(setdiff(librerias, rownames(installed.packages())))}
invisible(sapply(librerias, require, character.only = TRUE,quietly = TRUE))
###### ----------- Cargar datos --------- #######
##### --------- Datos acciones ------ #####
Acciones = as.data.frame(read_excel('Datos.xlsx',sheet = 'Close'))
Acciones= na.locf(Acciones)
## ---- Organizar nombres --- ###
rownames(Acciones) = Acciones[,'Fecha']
Acciones = Acciones[,-1]
## Vamos a generar la serie semanal ##
DatosSem=seq(as.Date(rownames(Acciones))[1],as.Date(rownames(Acciones))[nrow(Acciones)],by = "week")
# En caso de festivos, tomamos el dia mas cercano.
DatosSem=sapply(DatosSem,function(x){which.min(abs(as.Date(rownames(Acciones))-x))})
# Nos quedamos solo con los datos semanales
Acciones=Acciones[DatosSem,]
# Definimos una funcion que aplique el estimador de Shrink con suavizamiento exponencial.
shrinkEstimator = function(X){
retornos = X
lambda= 0.086
TiempoFin=nrow(X)
##Pesos
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
##Mu
mu=lambda/(1-(1-lambda)^TiempoFin)*w%*%X
mu=matrix(mu,ncol=1)
##Sigma
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
##
Sigma=matrix(0,ncol=ncol(X), nrow=ncol(X))
w=matrix((1-lambda)^(seq(TiempoFin-1,0)),ncol=TiempoFin)
w=matrix(rep(w,ncol(X)), ncol=ncol(X))
mu=matrix(rep(mu,ncol(t(retornos))),ncol=ncol(t(retornos)))
sigma=lambda/(1-(1-lambda)^TiempoFin)*(t(w*t((t(retornos)-mu)))%*%t((t(retornos)-mu)))
mu=mu[,1]
names(mu)=colnames(X)
I=diag(ncol(var(X)))
C=mean(eigen(var(X))$values)*I
Traza=0
for (i in 1:nrow(X)){
Traza=Traza+tr(((t(t(X[i,]))%*%t(X[i,]))-sigma)%*%(t(t(X[i,]))%*%t(X[i,]))-sigma)
}
alfa=((Traza/nrow(X)))/(tr(t(sigma-C)%*%(sigma-C))*nrow(X))
if (alfa>0.9){
alfa=0.9
}
if (alfa<0.1){
alfa=0.1
}
alfa=matrix(rep(alfa,ncol(X)*ncol(X)),nrow=ncol(X))
sigmaS=(1-alfa)*sigma+alfa*C
lambda = eigen(sigmaS)$values
N = ncol(retornos)
unos = rep(1,N)
b = (unos%*%solve(sigmaS)%*%t(t(mu)))/(unos%*%solve(sigmaS)%*%t(t(unos)))*unos
lambda = eigen(sigmaS)$values
alpha = 1/nrow(retornos)*(N*mean(lambda)-2*lambda[1])/(sum((mu-b)^2))
###############################################################################################
if(alpha>=0.9){ alpha=0.9 }
if(alpha<=0.1){ alpha=0.1 }
###############################################################################################
muS = (1-alpha)*mu + alpha*b
return( list(Sigma=sigmaS,mu=muS) )
}
# Generamos la serie de retornos
Retornos=na.omit(apply(Acciones,2,returns))
rownames(Retornos)=rownames(Acciones)[-1]
# Generamos cuatro estrategias (1,2,3,4): minima varianza en 2 y maximo retorno en 2.
# Una con shrink y otra con media y covarianza historica (estimador de max vero).
Retorno1=Retorno2=NULL
Retorno3=Retorno4=NULL
for(i in 52:(nrow(Retornos)-1)){
# Definimos que datos usar con un rolling window.
Datos=Retornos[(i-51):i,]
# Corremos nuestra funcion de shrink con suavizamiento.
Covarianza1=shrinkEstimator(Datos)
# Se lo asignamos a un vector de mu y sigma.
Mu1=Covarianza1$mu
Cov1=Covarianza1$Sigma
# Calibramos con maxima verosimilitud mu y sigma.
Mu2=colMeans(Datos)
Cov2=cov(Datos)
# Generamos una grilla de pesos para las dos acciones
w=matrix(seq(0,1,0.001),ncol=1)
w=cbind(w,1-w)
# Encontramos sigma y mu en la frontera.
Sigma1=apply(w,1,function(x){t(x)%*%Cov1%*%(x)})
Sigma2=apply(w,1,function(x){t(x)%*%Cov2%*%(x)})
Mu1=apply(w,1,function(x){t(x)%*%Mu1})
Mu2=apply(w,1,function(x){t(x)%*%Mu2})
# Tomamos los portafolios de minima varianza y maximo retorno
Portafolio1=w[which.min(abs(sqrt(Sigma1))),]
Portafolio2=w[which.min(abs(sqrt(Sigma2))),]
Portafolio3=w[which.max(Mu1),]
Portafolio4=w[which.max(Mu2),]
# Evaluamos la rentabilidad del portafolio una semana despues.
Retorno1=c(Retorno1,sum(Portafolio1*Retornos[i+1,]))
Retorno2=c(Retorno2,sum(Portafolio2*Retornos[i+1,]))
Retorno3=c(Retorno3,sum(Portafolio3*Retornos[i+1,]))
Retorno4=c(Retorno4,sum(Portafolio4*Retornos[i+1,]))
}
# Acumulamos los retornos para las estrategias de maxima rentabilidad.
Acum1=cumprod(Retorno3+1)
Acum2=cumprod(Retorno4+1)
plot(Acum1,type="l",ylim=range(c(Acum1,Acum2)))
par(new=T)
plot(Acum2,col=2,type="l",ylim=range(c(Acum1,Acum2)))
# Calculamos volatilidades de 30 dias
Varianza1=sapply(30:length(Retorno1),function(x){sd(Retorno1[(x-29):x])})
Varianza2=sapply(30:length(Retorno2),function(x){sd(Retorno2[(x-29):x])})
plot(Varianza1,type="l",ylim=range(c(Varianza1,Varianza2)))
par(new=T)
plot(Varianza2,col=2,type="l",ylim=range(c(Varianza1,Varianza2)))
###### --------------------- Ejercicio 2: Funcion de utilidad ----------------- ############
####### ----------- Limpiar ambiente ------- ######
rm(list = ls())
options(scipen = 10000000)
##### --------- Path: automatico  --------- #####
path <<- gsub(rstudioapi::getActiveDocumentContext()$path,pattern = "/Ejercicio 2.+",replacement = "")
setwd(paste0(path,'/Ejercicio 2'))
##### -------- librerias ------- ######
librerias <- c("readxl","ggplot2","scales",'timeSeries','timeSeries','forecast','rugarch','fBasics','moments','tseries','PortfolioAnalytics','dplyr','zoo','nleqslv')
###### ----- Instalacion liberarias ------ ####
if(length(setdiff(librerias, rownames(installed.packages()))) > 0){
install.packages(setdiff(librerias, rownames(installed.packages())))}
invisible(sapply(librerias, require, character.only = TRUE,quietly = TRUE))
##### --------- Datos acciones ------ #####
Acciones = as.data.frame(read_excel('Colcap.xlsx',sheet = 'Close'))
Acciones= na.locf(Acciones)
## ---- Organizar nombres --- ###
Fechas_originales = Acciones[,'Fecha']
Acciones = Acciones[,-1]
#### ------ Retornos simples ------ ####
Acciones = apply(Acciones, 2, function(x){returns(x,method='simple')})[-1,]
Acciones = as.data.frame(Acciones)
rownames(Acciones) = Fechas_originales[-1]
Acciones = Acciones[,c("GRUPOSURA","NUTRESA")]
###### ---------- Calcular frontera: Forma 2 -------- ##########
###### ------- Especificacion del portafolio ------ ######
espcartera<-portfolioSpec()
###### ------- Puntos de la frontera ------ ######
setNFrontierPoints(espcartera) <- 1000
###### ------- Restricciones: Positivas ------ ######
constraints="LongOnly"
###### ------- Construccion de la frontera ------ ######
Frontera <- portfolioFrontier(as.timeSeries(Acciones),spec=espcartera,constraints )
er_p_auto = Frontera@portfolio@portfolio$targetReturn[,'mean']
sd_p_auto = Frontera@portfolio@portfolio$targetRisk[,"Sigma"]
UtilidadPyG = function(DistribucionPyG,param){
#Funcion que mide la bondad de una distribucion de PyG. Funcion de utilidad u(x) = (x+b)^a,
#donde x es el PyG en DECIMALES, a<1. Esta funci?n se representa con una aversi?n al riesgo decreciente
#(igual a (1-a)/(x+L)), consistente con lo que se puede esperar en el manejo del libro. b puede ser visto
#como un nivel de tolerancia a p?rdidas m?ximas. Se devuelve una constante m?nima para valores por debajo.
if(param==1){
utilidad <- function(retorno) {
return(log(retorno))
}
}else{
utilidad <- function(retorno) {
return(((retorno)^(1-param)-1)/(1-param))
}
}
return(mean(sapply(DistribucionPyG,utilidad)))
}
######## -------- Estimacion del Parametro de Aversion ---------- #####
CalcularAversion = function(Equiv0){
Equiv0 = Equiv0/100
#     #Funcion que calibra la funcion de utilidad anterior a loterias equivalentes segun el nivel de PyG.
fun_resolver <- function(param,E1){
#### ----- Loteria 50%*U() + 50% U()
return(0.5*UtilidadPyG(1,param)+0.5*UtilidadPyG(2,param)-UtilidadPyG(1+E1,param))
}
return(nleqslv(ifelse(Equiv0>0,2,0), fun_resolver, E1=Equiv0, control=list(ftol=1e-14))$x)
}
## --- Paso 1: Ajustar el valor en millones --- ###
ParamAversion<<-CalcularAversion(Equiv0=20)
## --- Paso 2: Modelamos --- ###
Simulacion=sapply(1:length(er_p_auto),function(x){rnorm(10000,(1+er_p_auto[x])^250-1,sqrt(250)*sd_p_auto[x])})
PortOptim=which.max(apply(1+Simulacion,2,UtilidadPyG,param=ParamAversion))
plot((1+er_p_auto)^250-1,x=sqrt(250)*sd_p_auto,type="l",xlab="Volatilidad",ylab="Retorno")
