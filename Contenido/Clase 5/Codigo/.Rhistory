#ahora se encuentra el ciclo proyectado un paso adelante
cicloProy <- as.numeric(forecast(modeloCiclo,h = 1)$mean)
cicloProy
cicloProy
errorProy
#se suman los dos (un escalar y una matriz) para obtener una distribucion de ciclo mas error
#un paso adelante
cicloProy <- cicloProy + errorProy
cicloProy
#si no hay tendencia y/o estacionalidad deterministica hasta ahi llega el pronostico
#de lo contrario hay que enchufar lo demas
proyFin <- cicloProy
(fEstacional<=0.05)
fit_estacional
forecast(fit_estacional,h=1)
serie
dummyMensual(serie,h=1)
library(lubridate)
##### -------- librerias ------- ######
librerias <- c("readxl","ggplot2","scales",'timeSeries','forecast','rugarch','fBasics','moments','tseries','fPortfolio','data.table',"lubridate")
library("lubridate")
(dummyMensual(serie,h=1))
estacionalidadProy <- forecast(fit_estacional,newdata=as.data.frame(dummyMensual(serie,h=1)))$mean
estacionalidadProy
(fEstacional<=0.05)
(fCuadratico<=0.05)
length(serie)
length(serie)+1
(length(serie)+1)
(length(serie)+1)^2
tendenciaProy <- forecast(fit_cuadratico,newdata=data.frame(t=length(serie)+1,t2=(length(serie)+1)^2))$mean
tendenciaProy
proyFin <- proyFin + tendenciaProy
proyFin
#funcion para proyectar una distribucion con mil simulaciones un paso adelante
proyeccion_t_1 <- function(serie){
#se pasa a dataframe
seriePronosticar <- as.data.frame(serie)
#TENDENCIA DETERMINISTICA
#revisar tendencia lineal y cuadratica
fit_lineal <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar)))
mod_lineal <- summary(fit_lineal)
fit_cuadratico <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar),t2=(1:nrow(seriePronosticar))^2))
mod_cuadratico <- summary(fit_cuadratico)
#se obtiene el pvalor de la significancia conjunta
fLineal <- pf(mod_lineal$fstatistic[1],mod_lineal$fstatistic[2],mod_lineal$fstatistic[3],lower.tail = F)
fCuadratico <- pf(mod_cuadratico$fstatistic[1],mod_cuadratico$fstatistic[2],mod_cuadratico$fstatistic[3],lower.tail = F)
#si existe tendencia de algun tipo(lineal o cuadratica) se extrae de lo contrario se sigue con la misma
#serie
if(fCuadratico<=0.05){
errorTendencia <- mod_cuadratico$residuals
}else if(fLineal<=0.05){
errorTendencia <- mod_lineal$residuals
}else{
errorTendencia <- seriePronosticar
}
#ESTACIONALIDAD DETERMINISTICA
#se define nuevamente como un dataframe
errorTendencia <- data.frame(serie=errorTendencia)
#se utiliza funcion construida para obtener estacionalidad mensual
#se usa serie en la funcion de dummy mensual porque este es un vector que tiene
#las fechas en sus nombres, justo lo que recibe la funcion
fit_estacional <- lm(serie~.,data=cbind(errorTendencia,dummyMensual(serie)))
mod_estacional <- summary(fit_estacional)
#calculamos significancia conjunta
fEstacional <- pf(mod_estacional$fstatistic[1],mod_estacional$fstatistic[2],mod_estacional$fstatistic[3],lower.tail = F)
#si existe estacionalidad deterministica se extrae de lo contrario se sigue con la misma
#serie
if(fEstacional<=0.05){
errorEstacional <- mod_estacional$residuals
}else{
errorEstacional <- errorTendencia
}
#CICLO
#se define nuevamente como un dataframe
errorEstacional <- data.frame(serie=errorEstacional)
#se utiliza la funcion autoarima para identifica cual es la mejor estimacion de ciclo
#esto revisa tambien la tendencia estocastica (orden de integracion diferente de 0)
#y estacionalidad estocastica (ordenes sarima)
#escoge el mejor bajo el criterio AIC
modeloCiclo <- auto.arima(errorEstacional,seasonal  = T,stepwise = F,approximation = F)
errorCiclo <- modeloCiclo$residuals
names(errorCiclo) <- rownames(errorEstacional)
#RESIDUAL
#lo ultimo es revisar comportamientos autorregresivos en la volatilidad con Garch
#se revisa garch(1,0) garch(0,1) garch(1,1)
specArch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,0)))
specGarch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(0,1)))
specGarch11 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,1)))
#se ajusta dentro de muestra
fitArch1 <- ugarchfit(spec = specArch1, data = errorCiclo)
fitGarch1 <- ugarchfit(spec = specGarch1, data = errorCiclo)
fitGarch11 <- ugarchfit(spec = specGarch11, data = errorCiclo)
#se obtiene el BIC en los 3 casos
bic1 <- infocriteria(fitArch1)[2]
bic2 <- infocriteria(fitGarch1)[2]
bic3 <- infocriteria(fitGarch11)[2]
#se escoge el garch que minimice el BIC
fitGarch <- list(fitArch1,fitGarch1,fitGarch11)
fitGarch <- fitGarch[[which.min(c(bic1,bic2,bic3))]]
#PROYECCION
#se proyecta de atras para adelante, primero el residuo, luego el ciclo, luego estacionalidad y tendencia
#se hace una simulacion de 1000 errores posibles
errorProy <- ugarchsim(fit = fitGarch,
n.sim = 1,
m.sim = 1000)@simulation$seriesSim
#ahora se encuentra el ciclo proyectado un paso adelante
cicloProy <- as.numeric(forecast(modeloCiclo,h = 1)$mean)
#se suman los dos (un escalar y una matriz) para obtener una distribucion de ciclo mas error
#un paso adelante
cicloProy <- cicloProy + errorProy
#si no hay tendencia y/o estacionalidad deterministica hasta ahi llega el pronostico
#de lo contrario hay que enchufar lo demas
proyFin <- cicloProy
if(fEstacional<=0.05){ #si habia estacionalidad deterministica
estacionalidadProy <- forecast(fit_estacional,newdata=as.data.frame(dummyMensual(serie,h=1)))$mean
proyFin <- proyFin + estacionalidadProy
}
if(fCuadratico<=0.05){ #si hay tendencia cuadratica
tendenciaProy <- forecast(fit_cuadratico,newdata=data.frame(t=length(serie)+1,t2=(length(serie)+1)^2))$mean
proyFin <- proyFin + tendenciaProy
}else if(fLineal<=0.05){#si hay lineal
tendenciaProy <- forecast(fit_lineal,newdata=data.frame(t=length(serie)+1))$mean
proyFin <- proyFin + tendenciaProy
}
#se retorna la proyeccion
return(proyFin)
}
#funcion para obtener dummy mensual sea proyectada o dentro de muestra para una serie mensual
dummyMensual <- function(serie,h=NULL){
#serie <- ret_exito_ecopetrol[,1]
if(is.null(h)){#si no se quieren las futuras
#los meses de cada fecha
meses <- month(as.Date(names(serie)))
}else{ #si se quieren futuras
#se hace una secuencia semanal de una semana despues de la fecha observada hasta h semanas despues
meses = seq(as.Date(tail(names(serie),1))+weeks(1),
as.Date(tail(names(serie),1))+weeks(h),by = "weeks")
#se extraen los meses de las fechas
meses = month(meses)
}
#matriz de 11 columnas donde iran las dummies (se omite diciembre)
dummy = matrix(0, ncol = 11, nrow = length(meses))
#se llena la matriz
for(i in 1:nrow(dummy)){
if(meses[i]!=12){ #si es el mes 12 deberia ser 0 en todas
dummy[i,meses[i]] = 1
}
}
#se le ponen los nombres a las columnas
colnames(dummy) = c("Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct",
"Nov")
#se retorna
return(dummy)
}
#funcion para proyectar una distribucion con mil simulaciones un paso adelante
proyeccion_t_1 <- function(serie){
#se pasa a dataframe
seriePronosticar <- as.data.frame(serie)
#TENDENCIA DETERMINISTICA
#revisar tendencia lineal y cuadratica
fit_lineal <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar)))
mod_lineal <- summary(fit_lineal)
fit_cuadratico <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar),t2=(1:nrow(seriePronosticar))^2))
mod_cuadratico <- summary(fit_cuadratico)
#se obtiene el pvalor de la significancia conjunta
fLineal <- pf(mod_lineal$fstatistic[1],mod_lineal$fstatistic[2],mod_lineal$fstatistic[3],lower.tail = F)
fCuadratico <- pf(mod_cuadratico$fstatistic[1],mod_cuadratico$fstatistic[2],mod_cuadratico$fstatistic[3],lower.tail = F)
#si existe tendencia de algun tipo(lineal o cuadratica) se extrae de lo contrario se sigue con la misma
#serie
if(fCuadratico<=0.05){
errorTendencia <- mod_cuadratico$residuals
}else if(fLineal<=0.05){
errorTendencia <- mod_lineal$residuals
}else{
errorTendencia <- seriePronosticar
}
#ESTACIONALIDAD DETERMINISTICA
#se define nuevamente como un dataframe
errorTendencia <- data.frame(serie=errorTendencia)
#se utiliza funcion construida para obtener estacionalidad mensual
#se usa serie en la funcion de dummy mensual porque este es un vector que tiene
#las fechas en sus nombres, justo lo que recibe la funcion
fit_estacional <- lm(serie~.,data=cbind(errorTendencia,dummyMensual(serie)))
mod_estacional <- summary(fit_estacional)
#calculamos significancia conjunta
fEstacional <- pf(mod_estacional$fstatistic[1],mod_estacional$fstatistic[2],mod_estacional$fstatistic[3],lower.tail = F)
#si existe estacionalidad deterministica se extrae de lo contrario se sigue con la misma
#serie
if(fEstacional<=0.05){
errorEstacional <- mod_estacional$residuals
}else{
errorEstacional <- errorTendencia
}
#CICLO
#se define nuevamente como un dataframe
errorEstacional <- data.frame(serie=errorEstacional)
#se utiliza la funcion autoarima para identifica cual es la mejor estimacion de ciclo
#esto revisa tambien la tendencia estocastica (orden de integracion diferente de 0)
#y estacionalidad estocastica (ordenes sarima)
#escoge el mejor bajo el criterio AIC
modeloCiclo <- auto.arima(errorEstacional,seasonal  = T,stepwise = F,approximation = F)
errorCiclo <- modeloCiclo$residuals
names(errorCiclo) <- rownames(errorEstacional)
#RESIDUAL
#lo ultimo es revisar comportamientos autorregresivos en la volatilidad con Garch
#se revisa garch(1,0) garch(0,1) garch(1,1)
specArch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,0)))
specGarch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(0,1)))
specGarch11 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,1)))
#se ajusta dentro de muestra
fitArch1 <- ugarchfit(spec = specArch1, data = errorCiclo)
fitGarch1 <- ugarchfit(spec = specGarch1, data = errorCiclo)
fitGarch11 <- ugarchfit(spec = specGarch11, data = errorCiclo)
#se obtiene el BIC en los 3 casos
bic1 <- infocriteria(fitArch1)[2]
bic2 <- infocriteria(fitGarch1)[2]
bic3 <- infocriteria(fitGarch11)[2]
#se escoge el garch que minimice el BIC
fitGarch <- list(fitArch1,fitGarch1,fitGarch11)
fitGarch <- fitGarch[[which.min(c(bic1,bic2,bic3))]]
#PROYECCION
#se proyecta de atras para adelante, primero el residuo, luego el ciclo, luego estacionalidad y tendencia
#se hace una simulacion de 1000 errores posibles
errorProy <- ugarchsim(fit = fitGarch,
n.sim = 1,
m.sim = 1000)@simulation$seriesSim
#ahora se encuentra el ciclo proyectado un paso adelante
cicloProy <- as.numeric(forecast(modeloCiclo,h = 1)$mean)
#se suman los dos (un escalar y una matriz) para obtener una distribucion de ciclo mas error
#un paso adelante
cicloProy <- cicloProy + errorProy
#si no hay tendencia y/o estacionalidad deterministica hasta ahi llega el pronostico
#de lo contrario hay que enchufar lo demas
proyFin <- cicloProy
if(fEstacional<=0.05){ #si habia estacionalidad deterministica
estacionalidadProy <- forecast(fit_estacional,newdata=as.data.frame(dummyMensual(serie,h=1)))$mean
proyFin <- proyFin + estacionalidadProy
}
if(fCuadratico<=0.05){ #si hay tendencia cuadratica
tendenciaProy <- forecast(fit_cuadratico,newdata=data.frame(t=length(serie)+1,t2=(length(serie)+1)^2))$mean
proyFin <- proyFin + tendenciaProy
}else if(fLineal<=0.05){#si hay lineal
tendenciaProy <- forecast(fit_lineal,newdata=data.frame(t=length(serie)+1))$mean
proyFin <- proyFin + tendenciaProy
}
#se retorna la proyeccion
return(proyFin)
}
#se definen las series logaritmicas para tener todo en terminos aditivos
log_exito_ecopetrol <- log(exito_ecopetrol)
head(log_exito_ecopetrol)
#se hace una proyeccion de mil simulaciones de cada una de las acciones
proyeccion <- apply(log_exito_ecopetrol,2,proyeccion_t_1)
dim(proyeccion)
head(proyeccion)
#se pasa a niveles
proyeccion <- exp(proyeccion)
head(proyeccion)
tail(exito_ecopetrol)
apply(proyeccion,2,mean)
apply(proyeccion,2,sd)
##sacar retornos
ret_exito_ecopetrol_proy <- apply(proyeccion,2,returns,method='simple')
## quitar el primer elemento
ret_exito_ecopetrol_proy <- ret_exito_ecopetrol_proy[-1,]
##se sacan los retornos y las desviaciones historicas
mediasProy <- apply(ret_exito_ecopetrol_proy,2,mean)
sdProy <- apply(ret_exito_ecopetrol_proy,2,sd)
#comparar resultados con los historicos
##### --------- Media ------- #########
data.frame(Historia = mediasHist*100,GARCH = mediasProy*100)
##### --------- Garch ------- #########
data.frame( Historia = sdHist*100,GARCH = sdProy*100)
#Especificacion del portafolio
espFronteraProy <-portfolioSpec()
#Puntos de la frontera
setNFrontierPoints(espFronteraProy) <- 1000
# Restricciones: Positivas
constraints="LongOnly"
#Construccion de la frontera
Frontera_garch <- portfolioFrontier(as.timeSeries(ret_exito_ecopetrol_proy),spec=espFronteraProy,constraints )
er_p_auto_garch = Frontera_garch@portfolio@portfolio$targetReturn[,'mean']
sd_p_auto_garch = Frontera_garch@portfolio@portfolio$targetRisk[,"Sigma"]
w_Exito_auto_garch = Frontera_garch@portfolio@portfolio$weights[,"Exito"]
w_Ecopetrol_auto_garch = Frontera_garch@portfolio@portfolio$weights[,"Ecopetrol"]
#Consolidacion de resultados
Portafolio_resultados_garch = data.frame(er_p = er_p_auto_garch,sd_p = sd_p_auto_garch,w1=w_Exito_auto_garch,w2 = w_Ecopetrol_auto_garch)
plot(Frontera_garch)
##### ----- comparacion grafica de la frontera --- ######
graficarFrontera(Portafolio_resultados_garch,sdIni = sdProy,mediaIni = mediasProy)
graficarFrontera(portafolio=Portafolio_resultados,sdIni = sdHist,mediaIni = mediasHist)
##### ----- comparacion de los pesos optimos--- ######
Resultados_finales = cbind(Historico = efPortfolio_historico@portfolio@portfolio$weights, Garch = efPortfolio_garch@portfolio@portfolio$weights)
efPortfolio_garch <- efficientPortfolio(as.timeSeries(ret_exito_ecopetrol_proy),espFronteraProy,constraints)
##### ----- comparacion de los pesos optimos--- ######
Resultados_finales = cbind(Historico = efPortfolio_historico@portfolio@portfolio$weights, Garch = efPortfolio_garch@portfolio@portfolio$weights)
Resultados_finales
dev.off()
#'En este script se van a revisar, utilizando modelos multivariados tipo VAR y VECM una hipotesis
#'importantes de la economia.
# Existe una relacion importante (posiblemente unidireccional y de corto plazo) entre la inflacion y el desempleo
# Paquetes ------------------------------------------------------------------------------------
if (!require(dplyr))install.packages("dplyr");library(dplyr)
if (!require(tidyr))install.packages("tidyr");library(tidyr)
if (!require(xts))install.packages("xts");library(xts)
if (!require(ggplot2))install.packages("ggplot2");library(ggplot2)
if (!require(scales))install.packages("scales");library(scales)
if (!require(matrixStats))install.packages("matrixStats");library(matrixStats)
if (!require(readxl))install.packages("readxl");library(readxl)
if (!require(openxlsx))install.packages("openxlsx");library(openxlsx)
if (!require(httr))install.packages("httr");library(httr)
if (!require(lubridate))install.packages("lubridate");library(lubridate)
if (!require(forecast))install.packages("forecast");library(forecast)
if (!require(tseries))install.packages("tseries");library(tseries)
if (!require(vars))install.packages("vars");library(vars)
if (!require(tsDyn))install.packages("tsDyn");library(tsDyn)
path <- gsub("Clase5.R","",rstudioapi::getActiveDocumentContext()$path)
path
setwd(path)
# Paquetes ------------------------------------------------------------------------------------
rm(list=ls())
if (!require(dplyr))install.packages("dplyr");library(dplyr)
if (!require(tidyr))install.packages("tidyr");library(tidyr)
if (!require(xts))install.packages("xts");library(xts)
if (!require(ggplot2))install.packages("ggplot2");library(ggplot2)
if (!require(scales))install.packages("scales");library(scales)
if (!require(matrixStats))install.packages("matrixStats");library(matrixStats)
if (!require(readxl))install.packages("readxl");library(readxl)
if (!require(openxlsx))install.packages("openxlsx");library(openxlsx)
if (!require(httr))install.packages("httr");library(httr)
if (!require(lubridate))install.packages("lubridate");library(lubridate)
if (!require(forecast))install.packages("forecast");library(forecast)
if (!require(tseries))install.packages("tseries");library(tseries)
if (!require(vars))install.packages("vars");library(vars)
if (!require(tsDyn))install.packages("tsDyn");library(tsDyn)
path <- gsub("Clase5.R","",rstudioapi::getActiveDocumentContext()$path)
setwd(path)
#se lee los datos
datosModelo <- readRDS('datosCrudos.RDS')
head(datosModelo)
tail(datosModelo)
dim(datosModelo)
datosModelo[,-1]
datosModelo[,1]
datosModelo <- xts(datosModelo[,-1],order.by = datosModelo[,1])
plot(datosModelo)
tail(datosModelo)
dev.off()
#se separa train y test
datosPron <- 6
#se separa train y test
datosPron <- 6
head(head)
head(datosModelo)
head(datosModelo,10)
head(datosModelo,100)
nrow(datosModelo)
datosPron
data_train <- head(datosModelo,nrow(datosModelo)-datosPron)
tail(datosModelo,datosPron)
data_test <- tail(datosModelo,datosPron)
#revisar estacionariedad
#WTI estacionario
adf.test(data_train[,1], alternative="stationary")
#Brent estacionario
adf.test(data_train[,2], alternative="stationary")
#revisar estacionariedad
#WTI estacionario
adf.test(data_train[,1], alternative="stationary")
#Brent estacionario
adf.test(data_train[,2], alternative="stationary")
#ninguno de los dos es estacionario, queremos hacer diferencias, se guarda data_test como data_train_niveles
#y se crea uno en diferencias
data_train_niveles <- data_train
data_test_niveles <- data_test
tail(data_train,1)
data_test
#ae ponen en los niveles de test el ultimo de train solo para tener la diferencia del primer periodo
#luego se quita
data_test <- rbind(tail(data_train,1),data_test)
data_test
data_test[,1] <- diff(data_test[,1])
data_test[,2] <- diff(data_test[,2])
data_test <- data_test[complete.cases(data_test),]
data_test
data_train[,1] <- diff(data_train[,1])
data_train[,2] <- diff(data_train[,2])
head(data_train)
data_train <- data_train[complete.cases(data_train),]
head(data_train)
#se repite la prueba
adf.test(data_train[,1], alternative="stationary")
adf.test(data_train[,2], alternative="stationary")
VARselect(data_train, type="const")
p1
VARselect(data_train, type="const")
VARselect(data_train, type="const")$selection[3]
#escoger el p de VAR bajo el criterio de Schwarts
## con solo constante
p1 <- VARselect(data_train, type="const")$selection[3]
p1
VARselect(data_train, type="const",season=12)
## con solo constante y controlando por estacionalidad
p2 <- VARselect(data_train, type="const",season=12)$selection[3]
VARselect(data_train, type="trend")
## con tendencia deterministica
p3 <- VARselect(data_train, type="trend")$selection[3]
## con estacionalidad
p4 <- VARselect(data_train, type="trend",season=12)$selection[3]
## con ambas
p5 <- VARselect(data_train, type="both")$selection[3]
## con estacionalidad
p6 <- VARselect(data_train, type="both",season=12)$selection[3]
x=1
(paste0('p',x))
p1
#se identifica cuantos lags tiene este modelo
lagsVar <- get(paste0('p',x))
lagsVar
#se identifica cuantos lags tiene este modelo
lagsVar <- get(paste0('p',x))
#si es un numero par es porque tiene estacionalidad
#si es 1 o 2 es const, 3 o 4 es trend, 5 o 6 es ambas
if(x==1|x==2){
if(x==1){
modelo <- VAR(data_train, p=lagsVar, type="const")
}else{
modelo <- VAR(data_train, p=lagsVar, season=12,type="const")
}
}else if(x==3|x==4){
if(x==3){
modelo <- VAR(data_train, p=lagsVar, type="trend")
}else{
modelo <- VAR(data_train, p=lagsVar, season=12,type="trend")
}
}else{
if(x==5){
modelo <- VAR(data_train, p=lagsVar, type="both")
}else{
modelo <- VAR(data_train, p=lagsVar,season=12, type="both")
}
}
modelo
if (!require(abind))install.packages("abind");library(abind)
#se identifica cuantos lags tiene este modelo
lagsVar <- get(paste0('p',x))
#si es un numero par es porque tiene estacionalidad
#si es 1 o 2 es const, 3 o 4 es trend, 5 o 6 es ambas
if(x==1|x==2){
if(x==1){
modelo <- VAR(data_train, p=lagsVar, type="const")
}else{
modelo <- VAR(data_train, p=lagsVar, season=12,type="const")
}
}else if(x==3|x==4){
if(x==3){
modelo <- VAR(data_train, p=lagsVar, type="trend")
}else{
modelo <- VAR(data_train, p=lagsVar, season=12,type="trend")
}
}else{
if(x==5){
modelo <- VAR(data_train, p=lagsVar, type="both")
}else{
modelo <- VAR(data_train, p=lagsVar,season=12, type="both")
}
}
predict(modelo)
predict(modelo)$fcst
predict(modelo)$fcst$WTI
predict(modelo)$fcst$WTI[,1]
predict(modelo)$fcst$WTI[,2]
predict(modelo)$fcst$WTI[,3]
cbind(predict(modelo)$fcst$WTI[,1],
predict(modelo)$fcst$WTI[,2],
predict(modelo)$fcst$WTI[,3])
datosPron
1:datosPron
cbind(predict(modelo)$fcst$WTI[,1],
predict(modelo)$fcst$WTI[,2],
predict(modelo)$fcst$WTI[,3])[1:datosPron,]
#se extrae e pronostico y los intervalos de confianza del modelo para cada variable para el 2018
pronWTI <- cbind(predict(modelo)$fcst$WTI[,1],
predict(modelo)$fcst$WTI[,2],
predict(modelo)$fcst$WTI[,3])[1:datosPron,]
pronWTI
pronBrent<- cbind(predict(modelo)$fcst$Brent[,1],
predict(modelo)$fcst$Brent[,2],
predict(modelo)$fcst$Brent[,3])[1:datosPron,]
pronBrent
modelo
pronWTI
pronBrent
#se guardan en un array
arrayPronostico <- abind(pronWTI,pronBrent,along=3)
dim(pronWTI)
dim(pronBrent)
dim(arrayPronostico)
arrayPronostico[,,1]
pronWTI
arrayPronostico[,,2]
pronBrent
colnames(arrayPronostico) <- c('media','lim_inf','lim_sup')
dimnames(arrayPronostico)[[3]] <- c('WTI','Brent')
arrayPronostico
