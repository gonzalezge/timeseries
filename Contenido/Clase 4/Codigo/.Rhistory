## -- Ponga el nombre de las columnas
colnames(Historia_precios) = Historia_precios[1,]
#### ------ Elimine la primera fila de nombres
Historia_precios = Historia_precios[-1,]
#### ----- Todo numerico
Historia_precios = as.data.frame(apply(Historia_precios, 2, as.numeric))
#### ----- Arregle el formato de fechas
Historia_precios$Fecha = as.Date(Historia_precios$Fecha,origin = "1899-12-30")
#### ----- Modificar el nombre de las filas con las fechas
rownames(Historia_precios) =  Historia_precios$Fecha
#### ------- Eliminar fila de fecha
Historia_precios = Historia_precios[,-c(1)]
Historia_precios = as.matrix(Historia_precios)
#### ---- Vector de las empresas
Vector_de_empresas = colnames(Historia_precios)
### --- Tomar datos solo de cierre de semana
#wday identifica con un 6 los viernes
#se hace una secuencia diaria de viernes desde la priemra a la ultima fecha
viernes <- seq(as.Date(rownames(Historia_precios)[1]),
as.Date(rownames(Historia_precios)[nrow(Historia_precios)]),by='day')
viernes <- viernes[wday(viernes)==6]
#se busca la fecha mas cercana a cada viernes en la base (por izquierda)
posViernes <- sapply(viernes,function(x)
which(as.Date(rownames(Historia_precios))==
tail(as.Date(rownames(Historia_precios))[as.Date(rownames(Historia_precios))<=x],1)))
#se corta la base en estos
Historia_precios <- Historia_precios[posViernes,]
##Hacer submuestra solo con esos dos activos
exito_ecopetrol <- Historia_precios[,c("Exito","Ecopetrol")]
##sacar retornos
ret_exito_ecopetrol <- apply(exito_ecopetrol,2,returns,method='simple')
##volver a poner fechas y quitar el primer elemento
ret_exito_ecopetrol <- ret_exito_ecopetrol[-1,]
rownames(ret_exito_ecopetrol) <- rownames(exito_ecopetrol)[-1]
##se sacan los retornos y las desviaciones historicas
mediasHist <- apply(ret_exito_ecopetrol,2,mean)
sdHist <- apply(ret_exito_ecopetrol,2,sd)
mediasHist*100
sdHist*100
## se crean 1000 pesos de portafolios (omegas)
x_pesos <- seq(from = 0, to = 1, length.out = 1000)
pesos_portafolio <- data.frame(w_Exito = x_pesos,w_Ecopetrol = 1 - x_pesos)
##Calcular los retornos esperados para los 1000 portafolios posibles
er_portafolio = pesos_portafolio$w_Exito*mediasHist["Exito"] + pesos_portafolio$w_Ecopetrol*mediasHist["Ecopetrol"]
#Varianza
Covarianza = cov(ret_exito_ecopetrol)
pesos_portafolio_matrix = as.matrix(pesos_portafolio)
Varianza = sapply(c(1:1000), function(x){(pesos_portafolio_matrix[x,]%*%Covarianza)%*%(pesos_portafolio_matrix[x,])})
sd_portafolio = sqrt(Varianza)
#ConsolidaciÃ³n de resultados
Portafolio_resultados = data.frame(er_p = er_portafolio,sd_p = sd_portafolio,w1=pesos_portafolio$w_Exito,w2 = pesos_portafolio$w_Ecopetrol)
# Grafico resultados
graficarFrontera <- function(portafolio,sdIni,mediaIni){
ggplot() +
geom_point(data = portafolio, aes(x = sd_p, y = er_p, color = w1)) +
geom_point(data = data.table(sd = c(sdIni[1], sdIni[2]), mean = c(mediaIni[1], mediaIni[2])),
aes(x = sd, y = mean), color = "red", size = 3, shape = 18) + theme_bw() + ggtitle("Portafolios posibles") +
xlab("Volatilidad") + ylab("Retornos esperados") +
scale_color_continuous(name = expression(omega[x]), labels = percent)
}
graficarFrontera(portafolio=Portafolio_resultados,sdIni = sdHist,mediaIni = mediasHist)
#Calcular frontera: Forma 2
#Especificacion del portafolio
espFrontera<-portfolioSpec()
#Puntos de la frontera
setNFrontierPoints(espFrontera) <- 1000
# Restricciones: Positivas
constraints="LongOnly"
#Construccion de la frontera
Frontera <- portfolioFrontier(as.timeSeries(ret_exito_ecopetrol),spec=espFrontera,constraints )
er_p_auto = Frontera@portfolio@portfolio$targetReturn[,'mean']
sd_p_auto = Frontera@portfolio@portfolio$targetRisk[,"Sigma"]
w_Exito_auto = Frontera@portfolio@portfolio$weights[,"Exito"]
w_Ecopetrol_auto = Frontera@portfolio@portfolio$weights[,"Ecopetrol"]
#Consolidacion de resultados
Portafolio_resultados_auto = data.frame(er_p = er_p_auto,sd_p = sd_p_auto,w1=w_Exito_auto,w2 = w_Ecopetrol_auto)
#Grafico resultados automaticos
graficarFrontera(Portafolio_resultados_auto,sdIni = sdHist,mediaIni = mediasHist)
plot(Frontera)
######### --------- Resultado optimo ------- #########
efPortfolio_historico<- efficientPortfolio(as.timeSeries(ret_exito_ecopetrol),espFrontera,constraints)
#funcion para obtener dummy mensual sea proyectada o dentro de muestra para una serie mensual
dummyMensual <- function(serie,h=NULL){
#serie <- ret_exito_ecopetrol[,1]
if(is.null(h)){#si no se quieren las futuras
#los meses de cada fecha
meses <- month(as.Date(names(serie)))
}else{ #si se quieren futuras
#se hace una secuencia semanal de una semana despues de la fecha observada hasta h semanas despues
meses = seq(as.Date(tail(names(serie),1))+weeks(1),
as.Date(tail(names(serie),1))+weeks(h),by = "weeks")
#se extraen los meses de las fechas
meses = month(meses)
}
#matriz de 11 columnas donde iran las dummies (se omite diciembre)
dummy = matrix(0, ncol = 11, nrow = length(meses))
#se llena la matriz
for(i in 1:nrow(dummy)){
if(meses[i]!=12){ #si es el mes 12 deberia ser 0 en todas
dummy[i,meses[i]] = 1
}
}
#se le ponen los nombres a las columnas
colnames(dummy) = c("Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct",
"Nov")
#se retorna
return(dummy)
}
#serie = log_exito_ecopetrol[,1]
#funcion para proyectar una distribucion con mil simulaciones un paso adelante
proyeccion_t_1 <- function(serie){
#se pasa a dataframe
seriePronosticar <- as.data.frame(serie)
#TENDENCIA DETERMINISTICA
#revisar tendencia lineal y cuadratica
fit_lineal <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar)))
mod_lineal <- summary(fit_lineal)
fit_cuadratico <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar),t2=(1:nrow(seriePronosticar))^2))
mod_cuadratico <- summary(fit_cuadratico)
#se obtiene el pvalor de la significancia conjunta
fLineal <- pf(mod_lineal$fstatistic[1],mod_lineal$fstatistic[2],mod_lineal$fstatistic[3],lower.tail = F)
fCuadratico <- pf(mod_cuadratico$fstatistic[1],mod_cuadratico$fstatistic[2],mod_cuadratico$fstatistic[3],lower.tail = F)
#si existe tendencia de algun tipo(lineal o cuadratica) se extrae de lo contrario se sigue con la misma
#serie
if(fCuadratico<=0.05){
errorTendencia <- mod_cuadratico$residuals
}else if(fLineal<=0.05){
errorTendencia <- mod_lineal$residuals
}else{
errorTendencia <- seriePronosticar
}
#ESTACIONALIDAD DETERMINISTICA
#se define nuevamente como un dataframe
errorTendencia <- data.frame(serie=errorTendencia)
#se utiliza funcion construida para obtener estacionalidad mensual
#se usa serie en la funcion de dummy mensual porque este es un vector que tiene
#las fechas en sus nombres, justo lo que recibe la funcion
fit_estacional <- lm(serie~.,data=cbind(errorTendencia,dummyMensual(serie)))
mod_estacional <- summary(fit_estacional)
#calculamos significancia conjunta
fEstacional <- pf(mod_estacional$fstatistic[1],mod_estacional$fstatistic[2],mod_estacional$fstatistic[3],lower.tail = F)
#si existe estacionalidad deterministica se extrae de lo contrario se sigue con la misma
#serie
if(fEstacional<=0.05){
errorEstacional <- mod_estacional$residuals
}else{
errorEstacional <- errorTendencia
}
#CICLO
#se define nuevamente como un dataframe
errorEstacional <- data.frame(serie=errorEstacional)
#se utiliza la funcion autoarima para identifica cual es la mejor estimacion de ciclo
#esto revisa tambien la tendencia estocastica (orden de integracion diferente de 0)
#y estacionalidad estocastica (ordenes sarima)
#escoge el mejor bajo el criterio AIC
modeloCiclo <- auto.arima(errorEstacional,seasonal  = T,stepwise = F,approximation = F)
errorCiclo <- modeloCiclo$residuals
names(errorCiclo) <- rownames(errorEstacional)
#RESIDUAL
#lo ultimo es revisar comportamientos autorregresivos en la volatilidad con Garch
#se revisa garch(1,0) garch(0,1) garch(1,1)
specArch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,0)))
specGarch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(0,1)))
specGarch11 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,1)))
#se ajusta dentro de muestra
fitArch1 <- ugarchfit(spec = specArch1, data = errorCiclo)
fitGarch1 <- ugarchfit(spec = specGarch1, data = errorCiclo)
fitGarch11 <- ugarchfit(spec = specGarch11, data = errorCiclo)
#se obtiene el BIC en los 3 casos
bic1 <- infocriteria(fitArch1)[2]
bic2 <- infocriteria(fitGarch1)[2]
bic3 <- infocriteria(fitGarch11)[2]
#se escoge el garch que minimice el BIC
fitGarch <- list(fitArch1,fitGarch1,fitGarch11)
fitGarch <- fitGarch[[which.min(c(bic1,bic2,bic3))]]
#PROYECCION
#se proyecta de atras para adelante, primero el residuo, luego el ciclo, luego estacionalidad y tendencia
#se hace una simulacion de 1000 errores posibles
errorProy <- ugarchsim(fit = fitGarch,
n.sim = 1,
m.sim = 1000)@simulation$seriesSim
#ahora se encuentra el ciclo proyectado un paso adelante
cicloProy <- as.numeric(forecast(modeloCiclo,h = 1)$mean)
#se suman los dos (un escalar y una matriz) para obtener una distribucion de ciclo mas error
#un paso adelante
cicloProy <- cicloProy + errorProy
#si no hay tendencia y/o estacionalidad deterministica hasta ahi llega el pronostico
#de lo contrario hay que enchufar lo demas
proyFin <- cicloProy
if(fEstacional<=0.05){ #si habia estacionalidad deterministica
estacionalidadProy <- forecast(fit_estacional,newdata=as.data.frame(dummyMensual(serie,h=1)))$mean
proyFin <- proyFin + estacionalidadProy
}
if(fCuadratico<=0.05){ #si hay tendencia cuadratica
tendenciaProy <- forecast(fit_cuadratico,newdata=data.frame(t=length(serie)+1,t2=(length(serie)+1)^2))$mean
proyFin <- proyFin + tendenciaProy
}else if(fLineal<=0.05){#si hay lineal
tendenciaProy <- forecast(fit_lineal,newdata=data.frame(t=length(serie)+1))$mean
proyFin <- proyFin + tendenciaProy
}
#se retorna la proyeccion
return(proyFin)
}
#se definen las series logaritmicas para tener todo en terminos aditivos
log_exito_ecopetrol <- log(exito_ecopetrol)
#se hace una proyeccion de mil simulaciones de cada una de las acciones
proyeccion <- apply(log_exito_ecopetrol,2,proyeccion_t_1)
proyeccion
exito_ecopetrol
proyeccion_t_1
serie = log_exito_ecopetrol[,1]
log_exito_ecopetrol
head(log_exito_ecopetrol)
serie = log_exito_ecopetrol[,1]
serie
#se pasa a dataframe
seriePronosticar <- as.data.frame(serie)
#TENDENCIA DETERMINISTICA
#revisar tendencia lineal y cuadratica
fit_lineal <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar)))
mod_lineal <- summary(fit_lineal)
fit_cuadratico <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar),t2=(1:nrow(seriePronosticar))^2))
mod_cuadratico <- summary(fit_cuadratico)
#se obtiene el pvalor de la significancia conjunta
fLineal <- pf(mod_lineal$fstatistic[1],mod_lineal$fstatistic[2],mod_lineal$fstatistic[3],lower.tail = F)
fCuadratico <- pf(mod_cuadratico$fstatistic[1],mod_cuadratico$fstatistic[2],mod_cuadratico$fstatistic[3],lower.tail = F)
fCuadratico
fCuadratico<=0.05
if(fCuadratico<=0.05){
errorTendencia <- mod_cuadratico$residuals
}else if(fLineal<=0.05){
errorTendencia <- mod_lineal$residuals
}else{
errorTendencia <- seriePronosticar
}
errorTendencia
if(fCuadratico<=0.05){
errorTendencia <- mod_cuadratico$residuals
}else if(fLineal<=0.05){
errorTendencia <- mod_lineal$residuals
}else{
errorTendencia <- seriePronosticar
}
#ESTACIONALIDAD DETERMINISTICA
#se define nuevamente como un dataframe
errorTendencia <- data.frame(serie=errorTendencia)
#se utiliza funcion construida para obtener estacionalidad mensual
#se usa serie en la funcion de dummy mensual porque este es un vector que tiene
#las fechas en sus nombres, justo lo que recibe la funcion
fit_estacional <- lm(serie~.,data=cbind(errorTendencia,dummyMensual(serie)))
mod_estacional <- summary(fit_estacional)
#calculamos significancia conjunta
fEstacional <- pf(mod_estacional$fstatistic[1],mod_estacional$fstatistic[2],mod_estacional$fstatistic[3],lower.tail = F)
#si existe estacionalidad deterministica se extrae de lo contrario se sigue con la misma
#serie
if(fEstacional<=0.05){
errorEstacional <- mod_estacional$residuals
}else{
errorEstacional <- errorTendencia
}
errorEstacional
#CICLO
#se define nuevamente como un dataframe
errorEstacional <- data.frame(serie=errorEstacional)
#se utiliza la funcion autoarima para identifica cual es la mejor estimacion de ciclo
#esto revisa tambien la tendencia estocastica (orden de integracion diferente de 0)
#y estacionalidad estocastica (ordenes sarima)
#escoge el mejor bajo el criterio AIC
modeloCiclo <- auto.arima(errorEstacional,seasonal  = T,stepwise = F,approximation = F)
errorCiclo <- modeloCiclo$residuals
names(errorCiclo) <- rownames(errorEstacional)
errorCiclo
modeloCiclo
#RESIDUAL
#lo ultimo es revisar comportamientos autorregresivos en la volatilidad con Garch
#se revisa garch(1,0) garch(0,1) garch(1,1)
specArch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,0)))
modeloCiclo
#RESIDUAL
#lo ultimo es revisar comportamientos autorregresivos en la volatilidad con Garch
#se revisa garch(1,0) garch(0,1) garch(1,1)
specArch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,0)))
specGarch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(0,1)))
specGarch11 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,1)))
#RESIDUAL
#lo ultimo es revisar comportamientos autorregresivos en la volatilidad con Garch
#se revisa garch(1,0) garch(0,1) garch(1,1)
specArch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,0)))
specGarch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(0,1)))
specGarch11 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,1)))
#se ajusta dentro de muestra
fitArch1 <- ugarchfit(spec = specArch1, data = errorCiclo)
fitGarch1 <- ugarchfit(spec = specGarch1, data = errorCiclo)
fitGarch11 <- ugarchfit(spec = specGarch11, data = errorCiclo)
fitArch1
errorCiclo
specGarch11 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,1)))
#se ajusta dentro de muestra
fitArch1 <- ugarchfit(spec = specArch1, data = errorCiclo)
fitGarch1 <- ugarchfit(spec = specGarch1, data = errorCiclo)
fitGarch11 <- ugarchfit(spec = specGarch11, data = errorCiclo)
#se obtiene el BIC en los 3 casos
bic1 <- infocriteria(fitArch1)[2]
bic2 <- infocriteria(fitGarch1)[2]
bic3 <- infocriteria(fitGarch11)[2]
bic1
bic2
bic3
#se escoge el garch que minimice el BIC
fitGarch <- list(fitArch1,fitGarch1,fitGarch11)
fitGarch
[which.min(c(bic1,bic2,bic3))]
which.min(c(bic1,bic2,bic3))
which.min(c(bic1,bic2,bic3))
fitGarch[[which.min(c(bic1,bic2,bic3))]]
[which.min(c(bic1,bic2,bic3))]
which.min(c(bic1,bic2,bic3))
fitGarch <- fitGarch[[which.min(c(bic1,bic2,bic3))]]
fitGarch
#se hace una simulacion de 1000 errores posibles
errorProy <- ugarchsim(fit = fitGarch,
n.sim = 1,
m.sim = 1000)@simulation$seriesSim
#ahora se encuentra el ciclo proyectado un paso adelante
cicloProy <- as.numeric(forecast(modeloCiclo,h = 1)$mean)
errorProy
#se hace una simulacion de 1000 errores posibles
errorProy <- ugarchsim(fit = fitGarch,
n.sim = 1,
m.sim = 1000)@simulation$seriesSim
#ahora se encuentra el ciclo proyectado un paso adelante
cicloProy <- as.numeric(forecast(modeloCiclo,h = 1)$mean)
#se suman los dos (un escalar y una matriz) para obtener una distribucion de ciclo mas error
#un paso adelante
cicloProy <- cicloProy + errorProy
#si no hay tendencia y/o estacionalidad deterministica hasta ahi llega el pronostico
#de lo contrario hay que enchufar lo demas
proyFin <- cicloProy
if(fEstacional<=0.05){ #si habia estacionalidad deterministica
estacionalidadProy <- forecast(fit_estacional,newdata=as.data.frame(dummyMensual(serie,h=1)))$mean
proyFin <- proyFin + estacionalidadProy
}
if(fCuadratico<=0.05){ #si hay tendencia cuadratica
tendenciaProy <- forecast(fit_cuadratico,newdata=data.frame(t=length(serie)+1,t2=(length(serie)+1)^2))$mean
proyFin <- proyFin + tendenciaProy
}else if(fLineal<=0.05){#si hay lineal
tendenciaProy <- forecast(fit_lineal,newdata=data.frame(t=length(serie)+1))$mean
proyFin <- proyFin + tendenciaProy
}
#funcion para proyectar una distribucion con mil simulaciones un paso adelante
proyeccion_t_1 <- function(serie){
#se pasa a dataframe
seriePronosticar <- as.data.frame(serie)
#TENDENCIA DETERMINISTICA
#revisar tendencia lineal y cuadratica
fit_lineal <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar)))
mod_lineal <- summary(fit_lineal)
fit_cuadratico <- lm(serie~.,data = cbind(seriePronosticar,t=1:nrow(seriePronosticar),t2=(1:nrow(seriePronosticar))^2))
mod_cuadratico <- summary(fit_cuadratico)
#se obtiene el pvalor de la significancia conjunta
fLineal <- pf(mod_lineal$fstatistic[1],mod_lineal$fstatistic[2],mod_lineal$fstatistic[3],lower.tail = F)
fCuadratico <- pf(mod_cuadratico$fstatistic[1],mod_cuadratico$fstatistic[2],mod_cuadratico$fstatistic[3],lower.tail = F)
#si existe tendencia de algun tipo(lineal o cuadratica) se extrae de lo contrario se sigue con la misma
#serie
if(fCuadratico<=0.05){
errorTendencia <- mod_cuadratico$residuals
}else if(fLineal<=0.05){
errorTendencia <- mod_lineal$residuals
}else{
errorTendencia <- seriePronosticar
}
#ESTACIONALIDAD DETERMINISTICA
#se define nuevamente como un dataframe
errorTendencia <- data.frame(serie=errorTendencia)
#se utiliza funcion construida para obtener estacionalidad mensual
#se usa serie en la funcion de dummy mensual porque este es un vector que tiene
#las fechas en sus nombres, justo lo que recibe la funcion
fit_estacional <- lm(serie~.,data=cbind(errorTendencia,dummyMensual(serie)))
mod_estacional <- summary(fit_estacional)
#calculamos significancia conjunta
fEstacional <- pf(mod_estacional$fstatistic[1],mod_estacional$fstatistic[2],mod_estacional$fstatistic[3],lower.tail = F)
#si existe estacionalidad deterministica se extrae de lo contrario se sigue con la misma
#serie
if(fEstacional<=0.05){
errorEstacional <- mod_estacional$residuals
}else{
errorEstacional <- errorTendencia
}
#CICLO
#se define nuevamente como un dataframe
errorEstacional <- data.frame(serie=errorEstacional)
#se utiliza la funcion autoarima para identifica cual es la mejor estimacion de ciclo
#esto revisa tambien la tendencia estocastica (orden de integracion diferente de 0)
#y estacionalidad estocastica (ordenes sarima)
#escoge el mejor bajo el criterio AIC
modeloCiclo <- auto.arima(errorEstacional,seasonal  = T,stepwise = F,approximation = F)
errorCiclo <- modeloCiclo$residuals
names(errorCiclo) <- rownames(errorEstacional)
#RESIDUAL
#lo ultimo es revisar comportamientos autorregresivos en la volatilidad con Garch
#se revisa garch(1,0) garch(0,1) garch(1,1)
specArch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,0)))
specGarch1 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(0,1)))
specGarch11 <- ugarchspec(mean.model=list(armaOrder=c(0,0), include.mean=FALSE),
variance.model = list(garchOrder=c(1,1)))
#se ajusta dentro de muestra
fitArch1 <- ugarchfit(spec = specArch1, data = errorCiclo)
fitGarch1 <- ugarchfit(spec = specGarch1, data = errorCiclo)
fitGarch11 <- ugarchfit(spec = specGarch11, data = errorCiclo)
#se obtiene el BIC en los 3 casos
bic1 <- infocriteria(fitArch1)[2]
bic2 <- infocriteria(fitGarch1)[2]
bic3 <- infocriteria(fitGarch11)[2]
#se escoge el garch que minimice el BIC
fitGarch <- list(fitArch1,fitGarch1,fitGarch11)
fitGarch <- fitGarch[[which.min(c(bic1,bic2,bic3))]]
#PROYECCION
#se proyecta de atras para adelante, primero el residuo, luego el ciclo, luego estacionalidad y tendencia
#se hace una simulacion de 1000 errores posibles
errorProy <- ugarchsim(fit = fitGarch,
n.sim = 1,
m.sim = 1000)@simulation$seriesSim
#ahora se encuentra el ciclo proyectado un paso adelante
cicloProy <- as.numeric(forecast(modeloCiclo,h = 1)$mean)
#se suman los dos (un escalar y una matriz) para obtener una distribucion de ciclo mas error
#un paso adelante
cicloProy <- cicloProy + errorProy
#si no hay tendencia y/o estacionalidad deterministica hasta ahi llega el pronostico
#de lo contrario hay que enchufar lo demas
proyFin <- cicloProy
if(fEstacional<=0.05){ #si habia estacionalidad deterministica
estacionalidadProy <- forecast(fit_estacional,newdata=as.data.frame(dummyMensual(serie,h=1)))$mean
proyFin <- proyFin + estacionalidadProy
}
if(fCuadratico<=0.05){ #si hay tendencia cuadratica
tendenciaProy <- forecast(fit_cuadratico,newdata=data.frame(t=length(serie)+1,t2=(length(serie)+1)^2))$mean
proyFin <- proyFin + tendenciaProy
}else if(fLineal<=0.05){#si hay lineal
tendenciaProy <- forecast(fit_lineal,newdata=data.frame(t=length(serie)+1))$mean
proyFin <- proyFin + tendenciaProy
}
#se retorna la proyeccion
return(proyFin)
}
#se definen las series logaritmicas para tener todo en terminos aditivos
log_exito_ecopetrol <- log(exito_ecopetrol)
#se hace una proyeccion de mil simulaciones de cada una de las acciones
proyeccion <- apply(log_exito_ecopetrol,2,proyeccion_t_1)
proyeccion
#se pasa a niveles
proyeccion <- exp(proyeccion)
proyeccion
##sacar retornos
ret_exito_ecopetrol_proy <- apply(proyeccion,2,returns,method='simple')
## quitar el primer elemento
ret_exito_ecopetrol_proy <- ret_exito_ecopetrol_proy[-1,]
##se sacan los retornos y las desviaciones historicas
mediasProy <- apply(ret_exito_ecopetrol_proy,2,mean)
sdProy <- apply(ret_exito_ecopetrol_proy,2,sd)
ret_exito_ecopetrol_proy
sdProy
ret_exito_ecopetrol_proy
##sacar retornos
ret_exito_ecopetrol_proy <- apply(proyeccion,2,returns,method='simple')
## quitar el primer elemento
ret_exito_ecopetrol_proy <- ret_exito_ecopetrol_proy[-1,]
##se sacan los retornos y las desviaciones historicas
mediasProy <- apply(ret_exito_ecopetrol_proy,2,mean)
sdProy <- apply(ret_exito_ecopetrol_proy,2,sd)
ret_exito_ecopetrol_proy
#comparar resultados con los historicos
##### --------- Media ------- #########
data.frame(Historia = mediasHist*100,GARCH = mediasProy*100)
##### --------- Garch ------- #########
data.frame( Historia = sdHist*100,GARCH = sdProy*100)
#Especificacion del portafolio
espFronteraProy <-portfolioSpec()
#Puntos de la frontera
setNFrontierPoints(espFronteraProy) <- 1000
# Restricciones: Positivas
constraints="LongOnly"
#Construccion de la frontera
Frontera_garch <- portfolioFrontier(as.timeSeries(ret_exito_ecopetrol_proy),spec=espFronteraProy,constraints )
er_p_auto_garch = Frontera_garch@portfolio@portfolio$targetReturn[,'mean']
sd_p_auto_garch = Frontera_garch@portfolio@portfolio$targetRisk[,"Sigma"]
w_Exito_auto_garch = Frontera_garch@portfolio@portfolio$weights[,"Exito"]
w_Ecopetrol_auto_garch = Frontera_garch@portfolio@portfolio$weights[,"Ecopetrol"]
#Consolidacion de resultados
Portafolio_resultados_garch = data.frame(er_p = er_p_auto_garch,sd_p = sd_p_auto_garch,w1=w_Exito_auto_garch,w2 = w_Ecopetrol_auto_garch)
plot(Frontera_garch)
##### ----- comparacion grafica de la frontera --- ######
graficarFrontera(Portafolio_resultados_garch,sdIni = sdProy,mediaIni = mediasProy)
plot(Frontera)
##### ----- comparacion de los pesos optimos--- ######
Resultados_finales = cbind(Historico = efPortfolio_historico@portfolio@portfolio$weights, Garch = efPortfolio_garch@portfolio@portfolio$weights)
efPortfolio_garch <- efficientPortfolio(as.timeSeries(ret_exito_ecopetrol_proy),espFronteraProy,constraints)
##### ----- comparacion de los pesos optimos--- ######
Resultados_finales = cbind(Historico = efPortfolio_historico@portfolio@portfolio$weights, Garch = efPortfolio_garch@portfolio@portfolio$weights)
Resultados_finales
